#!/usr/bin/python3

##  Assignment-201948932
##  
##  Created by Hong Guen Ji on 14/05/20
##  VIM - Vi IMproved 8.0
##  Copyright Â© 2020 Hong Geun Ji. All rights reserved.
##
##  base64 encodeing, decoding and LFSR implementation
##  

import bindec

# string for the character's location based on base64
base64_str_lst = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"

# converts a character into a list of six 1's and 0's using Base64 encoding
def charToBin(c):
    
    # check1. if c is not a character,
    if type(c) != type('') or len(c) != 1:    # if c is not a character,
        print("You should only give a character")
        return None
        
    # check2. if c is not in base64
    if c not in base64_str_lst:
        print("There is a problem with base64 encoding, use only alphabet, digit, + or /")
        print("There is a character " + c + " in the string")
        return None
    
    return bindec.decToBin(base64_str_lst.index(c))
    

# converts a list of six 1's and 0's into a character using Base64 encoding
def binToChar(b):
    
    # check1. if b is not a list or does not have 6 binary numbers,
    if type(b) != type([]) or len(b) != 6:
        print("Please give an appropriate list with 6 binary numbers\n\n\n")
        return None
    
    # check2. if b contains any of the elements(digits) that is not 0 or 1,
    for digit in b:
        if digit not in [0,1]:
            print("Please give appropriate a list with binary numbers\n\n\n")
            return None
    
    return base64_str_lst[bindec.binToDec(b)]
    

# converts a string of characters into a list of 1's and 0's using Base64 encoding
def strToBin(s):
    str_to_bin_lst = []        # to return
    
    # check1. if s is not a string or s is empty,
    if type(s) != type('') or len(s) == 0:
        print("The string is not appropriate\n\n\n")
    
    for char_ in s:
        char_to_bin_lst = charToBin(char_)
        
        # check2. if there is an encoding problem,
        if not char_to_bin_lst:
            print("There is a problem indicated above\n\n\n")
            return None
        str_to_bin_lst += char_to_bin_lst
    
    return str_to_bin_lst


# convert a list of 1's and 0's into a string of characters using Base64 encoding
def binToStr(b_list):
    res_str = ""
    
    # check1. if b_list is not a list or b_list is empty,
    if type(b_list) != type([]) or len(b_list) == 0:
        print("Please give non-empty list\n\n\n")
        return
    
    for i in range(0, len(b_list), 6):
        bin_to_char = binToChar(b_list[i:i+6])
        
        # check2. if there is a decoding problem,
        if not bin_to_char:
            print("There is a problem indicated above\n\n\n")
            return None
        res_str += bin_to_char
        #print(res_str)
        
    return res_str


# returns a pseudo-random list of 1s and 0s, generated by an [N, k] LFSR, where N = length of seed
def generatePad(seed, k, l):
    pseudo_rand_list = []       # to return
    
    # check1. if seed is not a list
    if type(seed) != type([]) or not len(seed):
        print("seed is not valid\n\n\n")
        return None
    
    # check2. if k is not in appropriate range,
    if not (k > 0 and k < len(seed)):
        print("k should be bigger than 0 and lower than seed's length\n\n\n")
        return None
    
    N = len(seed)
    for i in range(l):
        left_most = seed[0]
        # check3. seed validation check
        if left_most not in [0,1]:
            print("seed is not valid\n\n\n")
            return None
        
        if left_most == seed[N-k]: pseudo_rand_list.append(0)
        else: pseudo_rand_list.append(1)
        seed = seed[1:]
        seed.append(pseudo_rand_list[-1])
    
    return pseudo_rand_list

# takes a string message and returns it as an encrypted string using an [N, k] LFSR
def encrypt(message, seed, k):
    
    encrypted_message_to_base64 = []
    pad = None
    message_to_base64 = strToBin(message)       # encode to base64
    message_to_base64_len = None if not message_to_base64 else len(message_to_base64)
    if message_to_base64_len: pad = generatePad(seed, k, message_to_base64_len)     # if the flow pass the message encoding validation
    
    if not message_to_base64 or not pad:        # final check
        print("Something went wrong because of the above reasons\n\n\n")
        return None
    
    for i in range(message_to_base64_len):
        if message_to_base64[i] == pad[i]: encrypted_message_to_base64.append(0)
        else: encrypted_message_to_base64.append(1)
        
    encrypted_message = binToStr(encrypted_message_to_base64)       # decode
    return encrypted_message
